Chain_Phi = chain_phi_dki,
Chain_Psi = psi_chain_k_ipd,
Chain_Mu = mu_chain_k_ip,
Chain_Sigma = Sigma_chain_k_ipp,
phyloseq = ps
)
rm(list = ls())
gc()
2+2
library(Rcpp)
library(RcppArmadillo)
library(devtools)
Rcpp::compileAttributes()
devtools::document()
devtools::install(build_vignettes = TRUE)
rm(list = ls())
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
#extract structures from phyloseq
tree.edge = phyloseq::phy_tree(ps)$edge
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
# model = LTNLDA_cov(ps = ps, K = K, C = 5, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
rm(list = ls())
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
# model = LTNLDA_(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
dtm = otu_table(ps)
dtm = phyloseq::otu_table(ps)
dim(dtm)
apply(dtm,2,sum)
apply(dtm,1,sum)
which(apply(dtm,1,sum)>100000)
model$Mean_Post_G_L
sum(model$Mean_Post_G_L)
sum(model$Mean_Post_G_L)/(22+11*21)
22*21/2
sum(model$Mean_Post_G_L[,,1])/(22+11*21)
model$Mean_Post_G_L[,,1]
model$Mean_Post_Beta_kd[1,]
model$Mean_Post_Beta_kd[1,,]
matplot(model$Mean_Post_Beta_kd[1,,],type="l")
Summary
sum
model$Mean_Post_Beta_k
model$Mean_Post_Beta_k[1,]
model$Mean_Post_Phi_d
matplot(model$Mean_Post_Beta_kd[2,,],type="l")
C
#extract structures from phyloseq
tree.edge = phyloseq::phy_tree(ps)$edge
dtm = phyloseq::otu_table(ps)
#find characteristics of tree
#find the root node
root = setdiff(tree.edge[,1],tree.edge[,2])
#find the internal nodes and reorder
internal_nodes = unique(tree.edge[,1])
internal_nodes = sort(internal_nodes)
internal_nodes_C = internal_nodes - 1
#find the maximum of the internal nodes
A = max(internal_nodes)
#find the set of leaves
leaves = setdiff(tree.edge[,2],tree.edge[,1])
#find the number of leaves
V = length(leaves)
#descendants[[i]] contains the two immediate descendants of node i
descendants = NULL
descendants_mat = matrix(0,ncol=2,nrow=max(tree.edge))
for(i in 1:max(tree.edge)){
if (sum(which(tree.edge[,1]==i))>0){
descendants[[i]] = tree.edge[which(tree.edge[,1] == i),2]
descendants_mat[i,] = descendants[[i]]
}
}
descendants_mat_C = descendants_mat - 1
#parents[i] contains the parent of node i
parents = NULL
for (i in 1:max(tree.edge)){
if (sum(which(tree.edge[,2]==i))>0){
parents[i] = tree.edge[which(tree.edge[,2]==i),1]
}
}
#ancestors[[i]] contains all of the ancestors of node i
ancestors = NULL
ancestors_C = NULL
for (i in 1:max(tree.edge)){
up=NULL
parent = parents[i]
while (is.na(parents[parent])==FALSE){
up = c(up,parent)
parent = parents[parent]
}
ancestors[[i]] = c(up,parent) #Adds the root of the tree as well
ancestors_C[[i]] = ancestors[[i]]-1
}
#layers[[i]] containts the nodes in the i^th layer of the tree
#layers[[1]] is the root node, layers[[2]] is the root nodes children, etc
layers = NULL
#initialize layer 2 and 1
#have to do an n-tuple (n>1) first, o/w this explodes
layers[[2]] = descendants[[root]]
layers[[1]] = root
for (i in 3:max(tree.edge)){
descend = NULL
for (j in 1:length(layers[[i-1]])){
descend = c(descend,descendants[[layers[[i-1]][j]]])
}
if ((sum(descend)>0)==TRUE){
layers[[i]] = descend
} else{
break
}
}
#left_leaves[[node]] contains the leaves left-descended from node
#right_leaves[[node]] contains the leaves right-descended from node
left_leaves = NULL
right_leaves = NULL
left_leaves[[max(internal_nodes)+1]] = rep(0,5)
right_leaves[[max(internal_nodes)+1]] = rep(0,5)
for (node in internal_nodes){
left_descend = NULL
right_descend = NULL
descend = descendants[[node]]
left = descend[1]
right = descend[2]
#if the descendant is a leaf we can termiante
if((left %in% leaves)==TRUE){
left_descend = left
} else {
#cycle through all of the leaves and see which are left descendants
for (nodes in leaves){
if((left %in% ancestors[[nodes]])==TRUE){
left_descend = c(left_descend,nodes)
}
}
}
left_leaves[[node]] = left_descend
#if the descendant is a leaf we can termiante
if((right %in% leaves)==TRUE){
right_descend = right
} else {
#cycle through all of the leaves and see which are right descendants
for (nodes in leaves){
if((right %in% ancestors[[nodes]])==TRUE){
right_descend = c(right_descend,nodes)
}
}
}
right_leaves[[node]] = right_descend
}
left_leaves[[max(internal_nodes)+1]] = NULL
right_leaves[[max(internal_nodes)+1]] = NULL
#leaf_success[[leaf]] contains the nodes from which leaf is left-descended
leaf_success = NULL
leaf_success_C = NULL
leaf_success[[max(leaves)+1]] = rep(0,5)
leaf_success_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
successes = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][1] %in% node_list)==TRUE){
successes = c(successes,node)
}
}
if (is.null(successes)==FALSE){
leaf_success[[leaf]] = successes
leaf_success_C[[leaf]] = successes - 1
} else {
leaf_success_C[[leaf]] = -1
}
}
leaf_success[[max(leaves)+1]]  = NULL
leaf_success_C[[max(leaves)+1]]  = NULL
#leaf_failures[[leaf]] contains the nodes from which leaf is right-descended
leaf_failures = NULL
leaf_failures[[max(leaves)+1]] = rep(0,5)
leaf_failures_C = NULL
leaf_failures_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
failures = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][2] %in% node_list)==TRUE){
failures = c(failures,node)
}
}
if (is.null(failures)==FALSE){
leaf_failures[[leaf]] = failures
leaf_failures_C[[leaf]] = failures - 1
} else {
leaf_failures_C[[leaf]] = -1
}
}
leaf_failures[[max(leaves)+1]] = NULL
leaf_failures_C[[max(leaves)+1]] = NULL
#come up with a mapping from internal nodes to 1:p
#node_map[internal_nodes] in {1,2,dots,p}
p = length(internal_nodes)
node_map = rep(0,A)
for(x in 1:p){
node_map[internal_nodes[x]] = x
}
#find the number of leaves descended from each node
#num_leaves[a] is the number of leaves descended from node a
num_leaves = rep(0,p)
for(x in 1:p){
num_leaves[x] = length(c(left_leaves[[internal_nodes[x]]], right_leaves[[internal_nodes[x]]]))
}
#make data structure recording which nodes belong in the upper part of the tree and which belong in the lower part
#U_nodes list the nodes in the upper matrix; p_U is the number of such nodes
#L_nodes list the nodes in the upper matrix; p_L is the number of such nodes
U_nodes = which(num_leaves >= C)
U_nodes_C = U_nodes - 1
p_U = length(U_nodes)
L_nodes = which(num_leaves < C)
L_nodes_C = L_nodes - 1
p_L = length(L_nodes)
U_nodes
node_map
node_map[64]
num_leaves
node_map[64]
num_leaves[20]
L_nodes
length(model$Chain_Psi)
dim(model$Chain_Psi[[2]])
dim(model$Chain_Psi[[2]])[,20,]
model$Chain_Psi[[2]][,20,]
model$Chain_Psi[[2]][1,U_nodes,]
matplot(model$Chain_Psi[[2]][1,U_nodes,],type="l")
model$Chain_Sigma[[2]]
model$Chain_Sigma[[2]][30,,]
model$Chain_Sigma[[2]][30,U_nodes,U_nodes]
which(node_map==20)
right_leaves[[64]]
dtm
dtm[25,]
model$Mean_Post_Beta_kd[2,,25]
model$Chain_Psi[[2]][30,,]
model$Chain_Psi[[2]][30,U_nodes,]
parent[25]
parent
parents
parents[25]
node_map[parents[25]]
Sigma = model$Chain_Sigma[[2]][30,,]
Sigma
Sigma[20,]
chol(Sigma)
chol(Sigma)[20,]
dim(model$Chain_Mu)
dim(model$Chain_Mu[[2]])
mu = model$Chain_Mu[[2]][30,]
mu
mu[20]
0.03867063*rnorm(D)  -0.6808762
0.03867063*rnorm(54)  -0.6808762
psi = model$Chain_Psi[[2]][30,]
psi = model$Chain_Psi[[2]][30,,]
psi
dim(psi)
psi[20,]
mean(psi[20,])
solve(Sigma)
solve(Sigma)[20,]
solve(Sigma) + diag(nrow(Sigma))
solve(solve(Sigma) + diag(nrow(Sigma)))
solve(solve(Sigma) + diag(nrow(Sigma)))[20,]
Sigma[20,]
psi
matplot(psi,type="l")
matplot(t(psi),type="l")
dim(psi)
matplot(t(psi[U_nodes,]),type="l")
matplot(t(psi[L_nodes,]),type="l")
matplot(t(psi[U_nodes,]),type="l")
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
# model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
model = LTNLDA_(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
Sigma = model$Chain_Sigma[[2]][30,,]
mu = model$Chain_Mu[[2]][30,]
psi = model$Chain_Psi[[2]][30,,]
matplot(psi[U_nodes,],type="l")
matplot(t(psi[U_nodes,]),type="l")
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
# model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
model = LTNLDA(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
Sigma = model$Chain_Sigma[[2]][30,,]
mu = model$Chain_Mu[[2]][30,]
psi = model$Chain_Psi[[2]][30,,]
matplot(t(psi[U_nodes,]),type="l")
matplot(t(psi[L_nodes,]),type="l")
matplot(model$Mean_Post_Phi_d)
matplot(model$Mean_Post_Phi_d,type="l")
psi[20,]
Sigma = model$Chain_Sigma[[2]][30,,]
Sigma
diag(Sigma)
mu = model$Chain_Mu[[2]][30,]
psi = model$Chain_Psi[[2]][30,,]
mu
save = model
save
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin)
# model = LTNLDA(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Chain_Sigma[[1]][,,37],type="l")
sum = Summary(model)
sum
Sigma = model$Chain_Sigma[[2]][30,,]
mu = model$Chain_Mu[[2]][30,]
psi = model$Chain_Psi[[2]][30,,]
Sigma_cov = model$Chain_Sigma[[2]][30,,]
Sigma = save$Chain_Sigma[[2]][30,,]
plot(Sigma,Sigma_cov)
mu = save$Chain_Mu[[2]][30,]
mu
mu_cov
mu_cov = model$Chain_Mu[[2]][30,]
mu = save$Chain_Mu[[2]][30,]
plot(mu,mu_cov)
lines(-5:10,-5:10)
psi = save$Chain_Psi[[2]][30,,]
psi_cov = model$Chain_Psi[[2]][30,,]
psi = save$Chain_Psi[[2]][30,,]
plot(psi,psi_cov)
lines(-10:10,-10:10)
psi
save$Mean_Post_Phi_d
model$Mean_Post_Phi_d
psi[,1]
psi_cov[,1]
psi_cov[,20]
psi[,20]
psi[20,]
psi_cov[20,]
plot(psi[U_nodes,],psi_cov[U_nodes,])
plot(psi[L_nodes,],psi_cov[L_nodes,])
matplot(model$Mean_Post_Beta_kd[1,,],type="l")
matplot(model$Mean_Post_Beta_kd[2,,],type="l")
matplot(save$Mean_Post_Beta_kd[2,,],type="l")
matplot(save$Mean_Post_Beta_kd[1,,],type="l")
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin,
a_L = 10, b_L = 10)
# model = LTNLDA(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Mean_Post_Beta_kd[2,,],type="l")
Sigma_cov = model$Chain_Sigma[[2]][30,,]
Sigma = save$Chain_Sigma[[2]][30,,]
mu_cov = model$Chain_Mu[[2]][30,]
mu = save$Chain_Mu[[2]][30,]
psi_cov = model$Chain_Psi[[2]][30,,]
psi = save$Chain_Psi[[2]][30,,]
sum = Summary(model)
sum
matplot(model$Mean_Post_Beta_kd[1,,],type="l")
matplot(model$Mean_Post_Phi_d)
matplot(model$Mean_Post_Phi_d,type="l")
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin,
a_L = 3, b_L = 3)
# model = LTNLDA(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Mean_Post_Beta_kd[1,,],type="l")
Sigma_cov = model$Chain_Sigma[[2]][30,,]
Sigma = save$Chain_Sigma[[2]][30,,]
mu_cov = model$Chain_Mu[[2]][30,]
mu = save$Chain_Mu[[2]][30,]
psi_cov = model$Chain_Psi[[2]][30,,]
psi = save$Chain_Psi[[2]][30,,]
sum = Summary(model)
sum
######################
# Gibbs Sampler Test #
######################
library(LTNLDA)
set.seed(1)
#load dataset
data("ps",package = "LTNLDA")
#Run Analsyis
K = 2
C = 5
iterations = 30
burnin = 300
thin = 1
model = LTNLDA_cov(ps, K = K, C = C,iterations = iterations, burnin = burnin, thin = thin,
a_L = 5, b_L = 5)
# model = LTNLDA(ps = ps, K = K, C = C, iterations = iterations, burnin = burnin, thin = thin)
matplot(model$Mean_Post_Beta_kd[1,,],type="l")
Sigma_cov = model$Chain_Sigma[[2]][30,,]
Sigma = save$Chain_Sigma[[2]][30,,]
mu_cov = model$Chain_Mu[[2]][30,]
mu = save$Chain_Mu[[2]][30,]
psi_cov = model$Chain_Psi[[2]][30,,]
psi = save$Chain_Psi[[2]][30,,]
sum = Summary(model)
sum
matplot(model$Mean_Post_Beta_kd[2,,],type="l")
matplot(model$Mean_Post_Phi_d,type="l")
Rcpp::compileAttributes()
devtools::document()
devtools::install(build_vignettes = TRUE)
