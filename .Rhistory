library(LTNLDA)
library(ggplot2)
set.seed(1)
#Define Parameters
true_K = 4
D = 50
N = 10000
alpha = 1
C = 5
addlog = function(a,b){
if ((a-b>50)==TRUE){
return(a)
} else if ((b-a>50)==TRUE){
return(b)
}
else {
return(a+log(1+exp(b-a)))
}
}
sublog = function(a,b){#a-b where a=log(x), b=log(y)
if ((a-b>50)==TRUE){
return(a)
} else if ((b-a>50)==TRUE){
return(-b)
}
else {
return(a+log(1-exp(b-a)))
}
}
# #let's hard code the tree into an edge matrix
# toy_tree = matrix(0,nrow=10,ncol=2)
#
# toy_tree[1,] = c(7,8)
# toy_tree[2,] = c(7,9)
# toy_tree[3,] = c(9,10)
# toy_tree[4,] = c(9,11)
# toy_tree[5,] = c(8,1)
# toy_tree[6,] = c(8,2)
# toy_tree[7,] = c(10,3)
# toy_tree[8,] = c(10,4)
# toy_tree[9,] = c(11,5)
# toy_tree[10,] = c(11,6)
#
# tree.edge = toy_tree #transferring some notation
#load tree structure - merged Sankaran
load("tree_mat.rda")
toy_tree = tree.edge
####################################################
# Convert Tree Edge Matrix into useable structures #
####################################################
#find characteristics of tree
#find the root node
root = setdiff(tree.edge[,1],tree.edge[,2])
#find the internal nodes and reorder
internal_nodes = unique(tree.edge[,1])
internal_nodes = sort(internal_nodes)
internal_nodes_C = internal_nodes - 1
#find the maximum of the internal nodes
A = max(internal_nodes)
#find the set of leaves
leaves = setdiff(tree.edge[,2],tree.edge[,1])
#find the number of leaves
V = length(leaves)
#Generate some tree data structures
#descendants[[i]] contains the two immediate descendants of node i
descendants = NULL
descendants_mat = matrix(0,ncol=2,nrow=max(tree.edge))
for(i in 1:max(tree.edge)){
if (sum(which(tree.edge[,1]==i))>0){
descendants[[i]] = tree.edge[which(tree.edge[,1] == i),2]
descendants_mat[i,] = descendants[[i]]
}
}
descendants_mat_C = descendants_mat - 1
#parents[i] contains the parent of node i
parents = NULL
for (i in 1:max(tree.edge)){
if (sum(which(tree.edge[,2]==i))>0){
parents[i] = tree.edge[which(tree.edge[,2]==i),1]
}
}
#ancestors[[i]] contains all of the ancestors of node i
ancestors = NULL
ancestors_C = NULL
for (i in 1:max(tree.edge)){
up=NULL
parent = parents[i]
while (is.na(parents[parent])==FALSE){
up = c(up,parent)
parent = parents[parent]
}
ancestors[[i]] = c(up,parent) #Adds the root of the tree as well
ancestors_C[[i]] = ancestors[[i]]-1
}
#layers[[i]] containts the nodes in the i^th layer of the tree
#layers[[1]] is the root node, layers[[2]] is the root nodes children, etc
layers = NULL
#initialize layer 2 and 1
#have to do an n-tuple (n>1) first, o/w this explodes
layers[[2]] = descendants[[root]]
layers[[1]] = root
for (i in 3:max(tree.edge)){
descend = NULL
for (j in 1:length(layers[[i-1]])){
descend = c(descend,descendants[[layers[[i-1]][j]]])
}
if ((sum(descend)>0)==TRUE){
layers[[i]] = descend
} else{
break
}
}
#left_leaves[[node]] contains the leaves left-descended from node
#right_leaves[[node]] contains the leaves right-descended from node
left_leaves = NULL
right_leaves = NULL
left_leaves[[max(internal_nodes)+1]] = rep(0,5)
right_leaves[[max(internal_nodes)+1]] = rep(0,5)
for (node in internal_nodes){
left_descend = NULL
right_descend = NULL
descend = descendants[[node]]
left = descend[1]
right = descend[2]
#if the descendant is a leaf we can termiante
if((left %in% leaves)==TRUE){
left_descend = left
} else {
#cycle through all of the leaves and see which are left descendants
for (nodes in leaves){
if((left %in% ancestors[[nodes]])==TRUE){
left_descend = c(left_descend,nodes)
}
}
}
left_leaves[[node]] = left_descend
#if the descendant is a leaf we can termiante
if((right %in% leaves)==TRUE){
right_descend = right
} else {
#cycle through all of the leaves and see which are right descendants
for (nodes in leaves){
if((right %in% ancestors[[nodes]])==TRUE){
right_descend = c(right_descend,nodes)
}
}
}
right_leaves[[node]] = right_descend
}
left_leaves[[max(internal_nodes)+1]] = NULL
right_leaves[[max(internal_nodes)+1]] = NULL
#need to find, for each leaf
# the nodes which have to succeed
# the nodes which have to fail
#in order for the leaf to be selected
#leaf_success[[leaf]] contains the nodes from which leaf is left-descended
leaf_success = NULL
leaf_success_C = NULL
leaf_success[[max(leaves)+1]] = rep(0,5)
leaf_success_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
successes = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][1] %in% node_list)==TRUE){
successes = c(successes,node)
}
}
if (is.null(successes)==FALSE){
leaf_success[[leaf]] = successes
leaf_success_C[[leaf]] = successes - 1
} else {
leaf_success_C[[leaf]] = -1
}
}
leaf_success[[max(leaves)+1]]  = NULL
leaf_success_C[[max(leaves)+1]]  = NULL
#leaf_failures[[leaf]] contains the nodes from which leaf is right-descended
leaf_failures = NULL
leaf_failures[[max(leaves)+1]] = rep(0,5)
leaf_failures_C = NULL
leaf_failures_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
failures = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][2] %in% node_list)==TRUE){
failures = c(failures,node)
}
}
if (is.null(failures)==FALSE){
leaf_failures[[leaf]] = failures
leaf_failures_C[[leaf]] = failures - 1
} else {
leaf_failures_C[[leaf]] = -1
}
}
leaf_failures[[max(leaves)+1]] = NULL
leaf_failures_C[[max(leaves)+1]] = NULL
#come up with a mapping from internal nodes to 1:p
#node_map[internal_nodes] in {1,2,dots,p}
p = length(internal_nodes)
node_map = rep(0,A)
for(x in 1:p){
node_map[internal_nodes[x]] = x
}
#find the number of leaves descended from each node
#num_leaves[a] is the number of leaves descended from node a
num_leaves = rep(0,p)
for(x in 1:p){
num_leaves[x] = length(c(left_leaves[[internal_nodes[x]]], right_leaves[[internal_nodes[x]]]))
}
#make data structure recording which nodes belong in the upper part of the tree and which belong in the lower part
#U_nodes list the nodes in the upper matrix; p_U is the number of such nodes
#L_nodes list the nodes in the upper matrix; p_L is the number of such nodes
U_nodes = which(num_leaves >= C)
U_nodes_C = U_nodes - 1
p_U = length(U_nodes)
L_nodes = which(num_leaves < C)
L_nodes_C = L_nodes - 1
p_L = length(L_nodes)
#define scale matrices for Inverse-Wishart covariance priors for upper and lower matrices
#initialized to diagonal matrices
Phi_U = diag(p_U)
Phi_L = diag(p_L)
#also define Lambda
Lambda = diag(p)
#this might be optimal?
#3 might be ok?
a_L = 4
b_L = 4*p
a_U = 10^4
b_U = 10
######################
# Generate true data #
######################
###################
#                 #
###################
# Data Generation #
###################
#                 #
###################
library(Rcpp)
library(RcppArmadillo)
library(statmod)
library(matrixStats)
library(rmutil)
library(zoo)
library(MCMCpack)
library(pgdraw)
library(RcppDist)
library(BayesianGLasso)
library(MCMCpack)
library(LTNLDA)
library(ggplot2)
set.seed(1)
#Define Parameters
true_K = 4
D = 50
N = 10000
alpha = 1
C = 3
addlog = function(a,b){
if ((a-b>50)==TRUE){
return(a)
} else if ((b-a>50)==TRUE){
return(b)
}
else {
return(a+log(1+exp(b-a)))
}
}
sublog = function(a,b){#a-b where a=log(x), b=log(y)
if ((a-b>50)==TRUE){
return(a)
} else if ((b-a>50)==TRUE){
return(-b)
}
else {
return(a+log(1-exp(b-a)))
}
}
#let's hard code the tree into an edge matrix
toy_tree = matrix(0,nrow=10,ncol=2)
toy_tree[1,] = c(7,8)
toy_tree[2,] = c(7,9)
toy_tree[3,] = c(9,10)
toy_tree[4,] = c(9,11)
toy_tree[5,] = c(8,1)
toy_tree[6,] = c(8,2)
toy_tree[7,] = c(10,3)
toy_tree[8,] = c(10,4)
toy_tree[9,] = c(11,5)
toy_tree[10,] = c(11,6)
tree.edge = toy_tree #transferring some notation
# #load tree structure - merged Sankaran
# load("tree_mat.rda")
# toy_tree = tree.edge
####################################################
# Convert Tree Edge Matrix into useable structures #
####################################################
#find characteristics of tree
#find the root node
root = setdiff(tree.edge[,1],tree.edge[,2])
#find the internal nodes and reorder
internal_nodes = unique(tree.edge[,1])
internal_nodes = sort(internal_nodes)
internal_nodes_C = internal_nodes - 1
#find the maximum of the internal nodes
A = max(internal_nodes)
#find the set of leaves
leaves = setdiff(tree.edge[,2],tree.edge[,1])
#find the number of leaves
V = length(leaves)
#Generate some tree data structures
#descendants[[i]] contains the two immediate descendants of node i
descendants = NULL
descendants_mat = matrix(0,ncol=2,nrow=max(tree.edge))
for(i in 1:max(tree.edge)){
if (sum(which(tree.edge[,1]==i))>0){
descendants[[i]] = tree.edge[which(tree.edge[,1] == i),2]
descendants_mat[i,] = descendants[[i]]
}
}
descendants_mat_C = descendants_mat - 1
#parents[i] contains the parent of node i
parents = NULL
for (i in 1:max(tree.edge)){
if (sum(which(tree.edge[,2]==i))>0){
parents[i] = tree.edge[which(tree.edge[,2]==i),1]
}
}
#ancestors[[i]] contains all of the ancestors of node i
ancestors = NULL
ancestors_C = NULL
for (i in 1:max(tree.edge)){
up=NULL
parent = parents[i]
while (is.na(parents[parent])==FALSE){
up = c(up,parent)
parent = parents[parent]
}
ancestors[[i]] = c(up,parent) #Adds the root of the tree as well
ancestors_C[[i]] = ancestors[[i]]-1
}
#layers[[i]] containts the nodes in the i^th layer of the tree
#layers[[1]] is the root node, layers[[2]] is the root nodes children, etc
layers = NULL
#initialize layer 2 and 1
#have to do an n-tuple (n>1) first, o/w this explodes
layers[[2]] = descendants[[root]]
layers[[1]] = root
for (i in 3:max(tree.edge)){
descend = NULL
for (j in 1:length(layers[[i-1]])){
descend = c(descend,descendants[[layers[[i-1]][j]]])
}
if ((sum(descend)>0)==TRUE){
layers[[i]] = descend
} else{
break
}
}
#left_leaves[[node]] contains the leaves left-descended from node
#right_leaves[[node]] contains the leaves right-descended from node
left_leaves = NULL
right_leaves = NULL
left_leaves[[max(internal_nodes)+1]] = rep(0,5)
right_leaves[[max(internal_nodes)+1]] = rep(0,5)
for (node in internal_nodes){
left_descend = NULL
right_descend = NULL
descend = descendants[[node]]
left = descend[1]
right = descend[2]
#if the descendant is a leaf we can termiante
if((left %in% leaves)==TRUE){
left_descend = left
} else {
#cycle through all of the leaves and see which are left descendants
for (nodes in leaves){
if((left %in% ancestors[[nodes]])==TRUE){
left_descend = c(left_descend,nodes)
}
}
}
left_leaves[[node]] = left_descend
#if the descendant is a leaf we can termiante
if((right %in% leaves)==TRUE){
right_descend = right
} else {
#cycle through all of the leaves and see which are right descendants
for (nodes in leaves){
if((right %in% ancestors[[nodes]])==TRUE){
right_descend = c(right_descend,nodes)
}
}
}
right_leaves[[node]] = right_descend
}
left_leaves[[max(internal_nodes)+1]] = NULL
right_leaves[[max(internal_nodes)+1]] = NULL
#need to find, for each leaf
# the nodes which have to succeed
# the nodes which have to fail
#in order for the leaf to be selected
#leaf_success[[leaf]] contains the nodes from which leaf is left-descended
leaf_success = NULL
leaf_success_C = NULL
leaf_success[[max(leaves)+1]] = rep(0,5)
leaf_success_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
successes = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][1] %in% node_list)==TRUE){
successes = c(successes,node)
}
}
if (is.null(successes)==FALSE){
leaf_success[[leaf]] = successes
leaf_success_C[[leaf]] = successes - 1
} else {
leaf_success_C[[leaf]] = -1
}
}
leaf_success[[max(leaves)+1]]  = NULL
leaf_success_C[[max(leaves)+1]]  = NULL
#leaf_failures[[leaf]] contains the nodes from which leaf is right-descended
leaf_failures = NULL
leaf_failures[[max(leaves)+1]] = rep(0,5)
leaf_failures_C = NULL
leaf_failures_C[[max(leaves)+1]] = rep(0,5)
for (leaf in leaves){
node_list=NULL
node_list = c(leaf,ancestors[[leaf]])
failures = NULL
for (node in ancestors[[leaf]]){
if ((descendants[[node]][2] %in% node_list)==TRUE){
failures = c(failures,node)
}
}
if (is.null(failures)==FALSE){
leaf_failures[[leaf]] = failures
leaf_failures_C[[leaf]] = failures - 1
} else {
leaf_failures_C[[leaf]] = -1
}
}
leaf_failures[[max(leaves)+1]] = NULL
leaf_failures_C[[max(leaves)+1]] = NULL
#come up with a mapping from internal nodes to 1:p
#node_map[internal_nodes] in {1,2,dots,p}
p = length(internal_nodes)
node_map = rep(0,A)
for(x in 1:p){
node_map[internal_nodes[x]] = x
}
#find the number of leaves descended from each node
#num_leaves[a] is the number of leaves descended from node a
num_leaves = rep(0,p)
for(x in 1:p){
num_leaves[x] = length(c(left_leaves[[internal_nodes[x]]], right_leaves[[internal_nodes[x]]]))
}
#make data structure recording which nodes belong in the upper part of the tree and which belong in the lower part
#U_nodes list the nodes in the upper matrix; p_U is the number of such nodes
#L_nodes list the nodes in the upper matrix; p_L is the number of such nodes
U_nodes = which(num_leaves >= C)
U_nodes_C = U_nodes - 1
p_U = length(U_nodes)
L_nodes = which(num_leaves < C)
L_nodes_C = L_nodes - 1
p_L = length(L_nodes)
#define scale matrices for Inverse-Wishart covariance priors for upper and lower matrices
#initialized to diagonal matrices
Phi_U = diag(p_U)
Phi_L = diag(p_L)
#also define Lambda
Lambda = diag(p)
#this might be optimal?
#3 might be ok?
a_L = 4
b_L = 4*p
a_U = 10^4
b_U = 10
######################
# Generate true data #
######################
###################
#                 #
###################
# Data Generation #
###################
#                 #
###################
#generate true Sigma_k^U
true_Sigma_U_ppk = array(0,dim=c(p_U,p_U,true_K))
for(k in 1:true_K){
for(a in 1:p_U){
true_Sigma_U_ppk[a,a,k] = 1/rgamma(1,shape = a_U,rate = b_U)
}
}
true_W_U_ppk =  array(0,dim=c(p_U,p_U,true_K))
for(k in 1:true_K){
true_W_U_ppk[,,k] = solve(true_Sigma_U_ppk[,,k])
}
true_Sigma_L_ppk
true_Sigma_U_ppk
